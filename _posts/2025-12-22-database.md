---
layout: post

title: 编程导论：2.3.数据库及其管理系统
author: hwshqtb
license: <p xmlns:cc="http://creativecommons.org/ns#" >本文的授权方式为 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">Creative Commons Attribution 4.0 International<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg" alt=""></a></p>

categories: programing
tags: programing-introduction
excerpt: "简要介绍数据库及数据库管理系统知识。"
---

* TOC
{:toc}

# 零、绪论
## 数据库、数据库管理系统及数据库系统
作为现代数据管理的重要技术，数据库基本上成为了互联网行业内的基础设施。当然，我们会从计算机的角度，通过ISO/IEC 9075-1:1999标准来分析研究它。

> ISO/IEC 9075-1:1999标准的电子整理版可以参见：https://sql-99.readthedocs.io/en/latest/
>
> 以及数据库管理系统事实上的标准：Microsoft Open Database Connectivity https://learn.microsoft.com/sql/odbc/microsoft-open-database-connectivity-odbc

**数据库**，可以视为是一种特殊的数据结构，其包含的数据类型可以归类为null、数字、字符串和BLOB（BinaryLargeOBjects，二进制大对象）。在支持传统数据结构增删查改四种功能的基础上，数据库能将数据持久化存储。通常将数据库的特点概括为：永久存储、有组织、可共享。

在数据库之上，组织协调用户与数据库沟通的组件即为**数据库管理系统**，其有以下功能：

- 数据库维护；
- 数据定义功能：提供DDL（Data Definition Language，数据定义语言），定义数据库中数据的组成和结构；
- 数据组织、存储和管理：确定数据库中数据的物理组织方式；
- 数据操纵功能：提供DML（Data Manipulation Language，数据操纵语言），通过其操纵数据库；
- 事务管理和运行管理：保证数据库及内部数据在多用户并发环境下的完整性、安全性及数据恢复。
- 通信功能：管理数据库与数据库管理系统外部交流。

**数据库系统**是将数据库、数据库管理系统（及应用开发工具）、各类用户组成的系统。在不混淆的情况下，可以将数据库系统称为数据库。

### 数据管理形态的演化
1. 人工管理阶段：20世纪50年代中期以前，由于计算机仅用于科学计算等用途，不存在数据存储的需要。
2. 文件系统阶段：至20世纪60年代，硬件存储出现，伴随着数据可以长期存储与硬件中。此时人们将数据直接存储于文件中，通过相应的文件系统访问数据。但此时由于软件的相互独立性，数据仅服务于特定的软件，数据间也基本不存在共享，冗余度较大。
3. 数据库管理系统计算：20世纪70年代的开始，数据日益丰富，同时硬件发展，使得数据库管理系统即成为可能也有必要。

| | 人工管理阶段 | 文件系统阶段| 数据库系统阶段|
|-|-|-|-|
|应用背景| 科学计算 |科学计算、数据管理| 大规模数据管理| 
|硬件背景| 无直接存取存储设备 |磁盘、磁鼓|大容量磁盘、磁盘阵列|
|软件背景|没有操作系统|有文件系统|有数据库管理系统|
|处理方式|批处理|联机实时处理、批处理|联机实时处理、分布处理、批处理|
|数据的管理者|用户（程序员）|文件系统|数据库管理系统|
|数据面向的对象|某一应用程序|某一应用|现实世界（一个部门、企业、跨国组织等）|
|数据的共享程度|无共享，冗余度极大|共享性差，冗余度大|共享性高，冗余度小|
|数据的独立性|不独立，完全依赖于程序|独立性差|具有高度的物理独立性和一定的逻辑独立性|
|数据的结构化|无结构|记录内有结构、整体无结构|整体结构化，用数据模型描述|
|数据控制能力|应用程序自己控制|应用程序自己控制|由数据库管理系统提供数据安全性、完整性、并发控制和恢复能力|

### 数据库系统的特点
1. 数据结构化：数据库存储的数据（组）具有自组织的特点，即数据（组）同时保存了各数据的一系列要求、属性，也保存了数据间的关系，具有一定的联系。整体上来看，相较于文件系统方式而言，数据库系统去除了（在文件系统上）文件间无关系的问题，实现了整体的结构化。
2. 数据的共享性高、冗余度低且易扩充：数据库系统从**整体角度**看待和描述数据，数据不再面向某个应用而是面向整个系统，因此数据可以被多个用户、多个应用共享使用。数据共享可以大大减少数据冗余，节约存储空间。数据共享还能够避免数据之间的不相容性与不一致性。而且数据库容易增加新的应用，这就使得数据库系统弹性大，易于扩充，可以适应各种用户的要求。
3. 数据独立性高：数据独立性是借助数据库管理数据的一个显著优点，包括数据的物理独立性和逻辑独立性。数据与程序的独立把数据的定义从程序中分离出去，加上存取数据的方法又由数据库管理系统负责提供，从而简化了应用程序的编制，大大减少了应用程序的维护和修改。
    - 物理独立性是指用户的应用程序与数据库中数据的物理存储是相互独立的。也就是 说，数据在数据库中怎样存储是由数据库管理系统管理的，用户程序不需要了解，应用程序要处理的只是数据的逻辑结构，这样当数据的物理存储改变时应用程序不用改变。
    - 逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。也就是说，数据 的逻辑结构改变时用户程序也可以不变。
4. 数据由数据库管理系统统一管理和控制
数据库的共享将会带来数据库的安全隐患，而数据库的共享是并发的共享。另外，数据库中数据的正确与一致也必须得到保障。为此，数据库管理系统提供以下几方面的数据控制功能。
	- 数据的安全性保护：保护数据以防止不合法使用造成的数据泄密和破坏。每个用户只能按规定对某些数据以某些方式进行使用和处理。
	- 数据的完整性检查：将数据控制在有效的范围内，并保证数据之间满足一定的关系，保证数据的正确性、有效性和相容性。
	- 并发控制：对多用户的并发操作加以控制和协调。
	- 数据库恢复：将数据库从错误状态恢复到某一已知的正确状态。

综上所述，数据库是长期存储在计算机内有组织、大量、共享的数据集合。它可以供各种用户共享，具有最小冗余度和较高的数据独立性。数据库管理系统在数据库建立、运用和维护时对数据库进行统一控制，以保证数据的完整性和安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复。

数据库系统的出现使信息系统从以加工数据的程序为中心转向围绕**共享的数据库为中心**的新阶段。

## 构建数据模型
数据模型是为了解决实际问题而给出的抽象化模型，是数据库系统的核心和基础。

### 概念模型
也称信息模型，它是按用户的观点来对数据和信息建模，主要用于数据库设计。概念模型应该具有较强的语义表达能力，能够方便、直接地表达应用中的各种语义知识，另一方面它还应该简单、清晰、易于用户理解。

组成部分有

- 实体
- 属性：实体的某一特性。应当**不可分**。
- 码/键：唯一标识实体的属性集。
- 实体型：实体名及其属性名集合，用于抽象和刻画同类实体。
- 实体集：同一类型实体的集合称为实体集。
- 联系：实体之间的联系通常是指不同实体集之间的联系，有一对一、一对多和多对多等多种类型。

表示方法——实体-联系图（E-R图）：矩形表示实体（名），圆角矩形表示属性，星形表示联系（名），用直线连接，在连接联系（名）与实体（名）的直线上标注联系的类型：一对一1:1、一对多1:n和多对多m:n。

### 逻辑模型
逻辑模型是概念模型的细化，旨在明确数据实体的属性、关系和约束。明确实体名称、属性的数据类型和精度，定义主键、唯一索引以及实体之间的关系。

常见的逻辑模型有：
1. 层次模型：实体间构成树。
2. 网状模型：实体间构成DAG。和层次模型统称为结构化模型。
3. 关系模型：实体间构成线性表。这是大多数数据库所采取的逻辑模型。
4. 面向对象模型：实体作为对象。
5. 对象关系模型：综合关系模型和面向对象模型。
6. 半结构化数据模型：以xml或类xml形式组织实体。

### 物理模型
物理模型通常由数据结构、数据操作和数据的完整性约束条件三部分组成。

1. 数据结构：描述数据库的组成对象以及对象之间的联系，是所描述的对象类型的集合，是对系统静态特性的描述。
2. 数据操作：指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，是对系统动态特性的描述，包括操作及有关的操作规则。数据库主要有查询和更新（包括插入、删除、修改）两大类操作。数据模型必须定义这些操作的确切含义、操作符号、操作规则（如优先级）以及实现操作的语言。
3. 数据的完整性约束条件：一组完整性规则，数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。 数据模型应该反映和规定其必须遵守的基本的和通用的完整性约束条件，还应该提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。

## 数据库系统的结构和组成
通常将数据库系统的逻辑结构和特征统称为模式，数据的集体称为实例。

### 模式
数据库系统将模式拆分为三个级别，与数据模型的三种相对应。

#### 逻辑模式
逻辑模式，也称模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。它是数据库系统模式结构的中间层，既不涉及数据的物理存储细节和硬件环境，又与具体的应用程序、所使用的应用开发工具及高级程序设计语言无关。模式实际上是数据库数据在逻辑级上的视图。一个数据库只有一个模式。

数据库模式以某一种逻辑模型为基础，统一综合地考虑了所有用户的需求，并将这些需求有机地结合成一个逻辑整体。定义模式时不仅要定义数据的逻辑结构，而且要定义数据之间的联系，定义数据的完整性约束条件。

数据库管理系统提供模式数据定义语言（模式 DDL）来严格地定义模式。

#### 外模式
外模式也称子模式或用户模式，它是数据库用户可见局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。外模式所表示的内容通常是模式所表示的内容的子集。一个数据库可以有多个外模式。

由于它是各个用户的数据视图，如果不同用户的需求存在差异，则其外模式描述就是不同的。另一方面，同一外模式也可以为某一用户的多个应用系统所使用。每个用户只能看见和访问所对应的外模式中的数据，数据库中的其余数据是不可见的。

数据库管理系统提供外模式数据定义语言（外模式DDL）来严格地定义外模式。

#### 内模式
内模式也称存储模式，是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。一个数据库只有一个内模式。

### 数据库的二级映像功能与数据独立性
为了能够在系统内部实现这三级模式的联系和转换，数据库管理系统在这三级模式之间提供了两层映像：外模式/模式映像和模式/内模式映像。正是这两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。

- 外模式/模式映像：当模式改变时(例如增加新的关系、新的属性、改变属性的数据类型等)，由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。
- 模式/内模式映像：当数据库的存储结构改变时，由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序的物理独立性。

### 数据库系统的组成
上述的内容在现实中就形成了以下数据库系统的组成：

- 硬件系统
- 数据库
- 数据库管理系统
- 用户
    - 管理员
	  - 系统分析员
    - 程序员
    - 最终用户

# 一、关系数据库
## 关系数据库理论
### 关系模型

#### 基本概念
||定义|类比二维表|
|-|-|-|
|域（domain）|一组具有相同数据类型的值的集合|某一量的可选范围|
|关系（relation）|若干域$D_i$的笛卡尔积的子集|一张二维表|
|属性（attribute）|关系在某一域上包含元素的集合|二维表的某一列|
|元组（tuple）|关系的某一元素|二维表的某一行|
|分量|元组在某一属性的值|某一行的某一列值|
|超码/超键（super key）|包含候选码的超集||
|候选码/候选键（candidate key）|完全函数确定关系的某属性组|能够唯一标识每一列的、但是其子集不能的属性组|
|主码/主键（primary key）|其中一个候选码||
|主属性（primary attribute）|候选码包含的属性||
|外码（foreign key）|与某一关系的主码对应||

关系的三种类型：
- 基本表/基本关系
- 查询表
- 视图表

基本关系的六（七）个性质：
- 列是同质；
- 不同列有不同属性名，以取消属性的有序性；
- 列之间无序；
- 元组的候选码两两不同；
- 行之间无序；
- 分量原子值/不可分。
- 关系应为有限的。

#### 关系模式
对关系的形式化描述，可以表示为
$$R(U,D,DOM,F)$$
其中R为关系名，U为组成该关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合。

#### 关系数据库
一个应用中的所有关系的集合。

关系数据库的型也称为关系关系数据库模式。值就是关系数据库自身。

### 关系数据库的操作
#### 操作种类
- 插入（增）
- 删除（删）
- 查询（查）
  - 基本操作
    - 选择
    - 投影
    - 并
    - 差
    - 笛卡尔积
  - 连接
  - 除
  - 交
- 更新（改）

操作的对象都是集合。

#### 操作的描述：关系数据语言
- 代数方法：关系代数
- 逻辑方式：关系演算
  - 元组关系演算
  - 域关系演算
- 结构化查询语言：SQL

### 关系完整性
#### 分类
实体完整性：基本关系的主属性不能取空值。
参照完整性：基本关系的外码要么取空值，要么等于相应主码的值。
用户定义的完整性：具体关系数据库的用户定义的约束条件，反映语义要求。

#### 违约处理
- 拒绝
- 级联
- 设置为空值

### 关系代数
#### 集合运算
略，同集合论

#### 关系运算
设$R_1(A_1,A_2,\ldots,A_n)$和$R_2(B_1,B_2,\ldots,B_m)$为关系，属性全集$U = \\{A_1,A_2,\ldots,A_n,B_1,B_2,\ldots,B_m\\}$

记：
- $t[A_i]$为元组t分量
- $t[A] = (t[A_1],t[A_2],\ldots,t[A_n])$
- $\overparen{t_rt_s} = (t_r[A_1],t_r[A_2],\ldots,t_r[A_n],t_s[B_1],t_s[B_2],\ldots,t_s[B_n])$
- 象集$Z_x = \\{t[Z]\mid \forall t\in R,t[X] = x\\}$，X为一属性组

- 选择：$\sigma_F(R) = \\{t\mid t\in R,F(t)\\}$
- 投影：$\Pi_A(R) = \\{t[A]\mid t\in R\\}$
- 连接：$R_1 \underset{F}{\Join} R_2 = \\{\overparen{t_rt_s}\mid t_r\in R_1,t_s\in R_2,F(t_r,t_s)\\}$
  - 等值连接：$F(t_r,t_s) \equiv t_r[A] = t_s[B]$
  - 自然连接：$R_1\Join R_2 = \\{\overparen{t_r t_s}[U]\mid t_r\in R_1,t_s\in R_2,t_r = t_s\\}$
  - 左外连接：$R_1 ⟕ R_2 = R_1\Join R_2 \cup ((R - \Pi_{R_1}(R_1\Join R_2)) \times null^m)$
  - 右外连接：$R_1 ⟖ R_2 = R_1\Join R_2 \cup (null^n \times (R - \Pi_{R_2}(R_1\Join R_2)))$
  - （全）外连接：$R_1 ⟗ R_2 = R_1 ⟕ R_2 \cup R_1 ⟖ R_2$
- 除：$R_1 \div R_2 = \\{t[U_{R_1} - Y]\mid t\in R_1,\Pi_Y(R_2)\subseteq Y_{t[U_{R_1} - Y]}\\}$，其中Y为选定的属性组，$Y \subseteq U_{R_1} \cup U_{R_2}$

### 数据库安全性
保护数据库以防止不合法使用所造成的数据泄露、更改或破坏。

#### 数据库的不安全因素
- 非授权用户对数据库的恶意存取和破坏
- 数据库中重要或敏感的数据被泄露
- 安全环境的脆弱性

#### 安全标准
常见安全标准
- TCESC（桔皮书）、ITSEC、CTCPEC、FC
- CC

数据库安全标准：
- TCSEC/TDI 紫皮书：D——C1（DAC）——C2（受控的存取保护）-B1（标记安全保护、MAC）-B2（结构化保护）-B3（安全域）-A（验证设计）
- CC：EAL1~EAL7：功能测试——结构测试——系统地测试和检查——系统地设计、测试和复查——半形式化设计和测试——半形式化验证的设计和测试——形式化的设计和测试

#### 安全控制
- 用户身份鉴别：静态口令、动态口令、生物特征鉴别、智能卡鉴别
- 存取控制：定义用户权限并登记到数据字典、合法用户检查
  - 用户权限=数据库对象+操作类型
  - DAC：自主存取控制：用户拥有权限，授予、收回权限
  - MAC：对象拥有密级（TS、S、C、P），用户拥有许可证，读需要许可证≥密级，写需要许可证≤密级。
- 审计：记录操作日志
- 数据加密：存储加密、传输加密

## SQL
### 基本概念
$\overset{Data Definition Language}{数据定义语言}$：定义和管理数据库中的数据结构和对象。

视图——基本表——存储文件三级结构。

### 特点
- 综合统一：集模式数据定义语言、外模式数据定义语言、数据存储有关的描述语言、数据操纵语言为一体的统一语言
- 高度非过程化/结构化
- 面向集合的操作模式
- 以同一种语法结构提供多种使用方式
- 语言简洁，易学易用

### 语法
注：下方标记`？`的为非标准功能

#### 特殊单词
级联操作
- `RESTRICT`：存在依赖时取消/拒绝执行
- `CASCADE`：同时对依赖执行

数据类型`<Data type>`
|数据类型|定义|
|-|-|
|`CHAR(n),CHARACTER(n)`|定长n字符串|
|`VARCHAR(n),CHARACTERVARYING(n)`|最长n字符串|
|`CLOB`|长字符串|
|`BLOB`|二进制数据|
|`INT`/`INTEGER`|4B整数|
|`SMALLINT`|2B整数|
|`BIGINT`|8B整数|
|`NUMERIC(p,d)`/`DECIMAL(p,d)`/`DEC(p,d)`|p位整数和d位小数|
|`REAL`|单精度浮点数|
|`DOUBLE PRECISION`|双精度浮点数|
|`FLOAT(n)`|至少n精度的浮点数|
|`BOOLEAN`|布尔值|
|`DATE`|日期|
|`TIME`|时间|
|`TIMESTAMP`|时间戳|
|`INTERVAL`|时间间隔|

次序
- `ASC`：升序，默认
- `DESC`：降序

重复
- `DISTINCT`：去重
- `ALL`：不去重，默认

检查合法性
- `WITH CHECK OPTION`：在操作时检查数据的合法性
- `WITH GRANT OPTION`：在授权时检查数据的合法性

通配符
- `%`：匹配0个或多个字符
- `_`：匹配一个字符

#### 运算符

|运算符|定义|
|-|-|
|`+`|加法|
|`-`|减法|
|`*`|乘法|
|`/`|除法|
|`%`|取余|
|`||`|字符串连接|
|`&`|位与|
|`|`|位或|
|`^`|位异或|
|`~`|位取反|
|`<<`|左移|
|`>>`|右移|
|`=`|等于|
|`!=`|不等于|
|`<`|小于|
|`>`|大于|
|`<=`|小于等于|
|`>=`|大于等于|
|`AND`|逻辑与|
|`OR`|逻辑或|
|`NOT`|逻辑非|

#### 谓词

|谓词|定义|
|-|-|
|`IS NULL`|空值|
|`IS NOT NULL`|非空值|
|`IN`|在集合中|
|`LIKE`|模糊匹配|
|`BETWEEN`|在区间内|
|`EXISTS`|存在|
|`ALL`|满足所有谓词|
|`SOME`|满足任意谓词|
|`ANY`|满足任意谓词|

#### 聚集函数

|聚集函数|定义|
|-|-|
|`COUNT`|计数|
|`MAX`|最大值|
|`MIN`|最小值|
|`SUM`|求和|
|`AVG`|平均值|

#### 模式
定义：`<Schema create> ::= CREATE TABLE [<Schema name>] AUTHORIZATION <AuthorizationID> [<Table create> | <View create> | <Grant>]`
  * `<Schema name>`默认为`<AuthorizationID>`

删除：`DROP SCHEMA <Schema name> {RESTRICT | CASCADE}`

#### 基本表
定义：`CREATE TABLE [<Schema name>.]<Table name> "("<Column name> <Data type> [<Column Constraint>] [, <Column name> <Data type> [<Column Constraint>]]... [,<Table constraint>]]")" `

修改：`ALTER TABLE <Table name> [ADD [COLUMN] <Column name> <Data type> [<Column Constraint>]] [ADD <Table constraint>] [DROP [COLUMN] <Column name> {RESTRICT | CASCADE}] [DROP CONSTRAINT <Table constraint name> {RESTRICT | CASCADE}] [ALTER COLUMN <Column name> <Data type>]`

删除：`DROP TABLE <Table name> {RESTRICT | CASCADE}`

插入元组：`INSERT INTO <Table name> "("<Column name> [, <Column name>]...")" {VALUES "("<Value> [, <Value>]...)")" | <select>}`

修改元组：`UPDATE <Table name> SET "("<Column name> = <Value> [, <Column name> = <Value>]...")" [WHERE <Where condition>]`

删除元组：`DELETE FROM <Table name> [WHERE <Where condition>]`

#### 索引
定义：`CREATE [UNIQUE] [CLUSTER] INDEX <Index name> ON <Table name> "("<Index attribute> [ASC | DESC] [, <Index attribute> [ASC | DESC]]...")"`

修改：`ALTER INDEX <Index name> RENAME TO <Index name>`

删除：`DROP INDEX <Index name>`

#### 查询
`SELECT [ALL | DISTINCT] {({<Column expression> [AS <name>]} [, {<Column expression> [AS <name>]}]...) | *}`

`FROM {({<Table name> | <View name>} [AS <name>] [, {<Table name> | <View name>} [AS <name>]]...) | ( (<select>) [AS] <name>)}`

`[WHERE <Where condition>]`

`[GROUP BY <Column name> [HAVING <Group condition>]]`

`[ORDER BY <Column name> [ASC | DESC] [, <Column name> [ASC | DESC]]...]`

其中的`<select>`称为子查询，分为：
- 相关子查询：子查询的WHERE子句中引用了外部查询的表，执行依赖于外部查询。
- 不相关子查询：

#### 视图
定义：`CREATE VIEW <View name> [<Column name> [, <Column name>]...] AS <select> [WITH CHECK OPTION]`

删除：`DROP VIEW <View name> [CASCADE]`

#### 完整性约束
实体完整性约束：`PRIMARY KEY`，`PRIMARY KEY"("<Column name> [, <Column name>]...")"`
参照完整性约束：`FOREIGN KEY "("<Column name>")" REFERENCES <Table name>"("<Column name>")"`
用户定义的完整性：`NOT NULL`，`UNIQUE`，`CHECK <check contidion>`
完整性约束子句定义：`CONSTRAINT <Constraint name> <Constraint type> "("<Column name> [, <Column name>]...")"`
完整性约束子句删除：`ALTER TABLE <Table name> DROP CONSTRAINT <Constraint name>`

#### 授权
授予：`GRANT <Privilege> [, <Privilege>]... ON <type> <name> [, [<type> <name]]... TO <AuthorizationID> [, <AuthorizationID>]... [WITH GRANT OPTION]`

收回：`REVOKE <Privilege> [, <Privilege>]... ON <type> <name> [, [<type> <name]]... FROM <AuthorizationID> [, <AuthorizationID>]... [CASCADE | RESTRICT]`

创建角色：`CREATE ROLE <Role name>`

授权角色：`GRANT <Privilege> [, <Privilege>]... ON <type> <name> [, [<type> <name]]... TO <Role name> [, <Role name>]...`

角色授予用户：`GRANT <Role name> [, <Role name>]... TO <AuthorizationID> [, <AuthorizationID>]... [WITH ADMIN OPTION]`

收回角色授权：`REVOKE <Privilege> [, <Privilege>]... ON <type> <name> [, [<type> <name]]... FROM <Role name> [, <Role name>]...`

？创建用户：`CREATE USER <AuthorizationID> [WITH] {DBA | RESOURCE | CONNECT}`

#### 审计
？启用审计：`ADULT <Privilege> [, <Privilege>]... ON <name>`>

？禁用审计：`NOADULT <Privilege> [, <Privilege>]... ON <name>`

#### 嵌入式SQL
编译流程：
- 预编译：DBMS预处理程序将嵌入式SQL语句转换为宿主语言
- 编译：宿主语言编译

C语言嵌入式语句：`EXEC SQL <SQL statement>;`

JAVA嵌入式语句：`# SQL {<SQL statement>};`

通信区定义：`INCLUDE SQLCA`
- `SQLCA.SQLCODE`用于指示操作是否成功

主变量定义：`BEGIN DECLARE SECTION` `END DECLARE SECTION`
- 主变量使用时前面加`:`
- 使用时主变量后可附加使用一个指示变量

游标：`DECLARE <Cursor name> CURSOR FOR <SQL statement>`

打开游标：`OPEN <Cursor name>`

关闭游标：`CLOSE <Cursor name>`

遍历游标：`FETCH <Cursor name> INTO <Variable name> [, <Variable name>]...`

建立数据库连接：`SET CONNECTION TO {<Connection name> | DEFAULT}`

关闭数据库连接：`DISCONNECTION {<Connection name> | DEFAULT}`

提交更新：`COMMIT WORK`

执行动态SQL语句：`EXECUTE IMMEDIATE <Variable name>`

准备动态SQL语句：`PREPARE <Statement name> FROM <Variable name>`
- 在被准备的语句`<Variable name>`中用`?`代替参数

执行准备好的动态SQL语句：`EXECUTE <Statement name> [INTO <Variable name>] USING <Variable name>`

#### 事务
开始事务：`BEGIN TRANSACTION`

提交事务：`COMMIT`

回滚事务：`ROLLBACK`

# 二、数据库应用
## 关系数据理论
引入对关系数据库对的规范化理论。为了解决：
- 数据冗余
- 更新异常
- 插入异常
- 删除异常

### 数据依赖
关系的内部属性之间的约束关系。是语义上考虑的。

函数依赖：对属性组X和Y，该关系模式的任一关系中不存在两个元组t1和t2，使得$t1[X] = t2[X]$且$t1[Y] \neq t2[Y]$，即属性组X和Y构成函数关系$F:X \rightarrow Y$，记作$X \rightarrow Y$。此时X为决定因素。否则记为$X \not \rightarrow Y$

平凡函数依赖：$X \rightarrow Y$且$Y \subseteq X$，否则为非平凡的。

若$X \rightarrow Y$且$Y \rightarrow X$，则记为$X \leftarrow \rightarrow Y$。

完全函数依赖：$X \rightarrow Y$ 且$\forall X^\prime \subset X,X^\prime \not \rightarrow F$，记作$X \overset{F}{\rightarrow Y}$。否则为部分函数依赖，记为$X \overset{P}{\rightarrow Y}$。

传递函数依赖：若Y不平凡函数依赖于X、X不函数依赖于Y、Z不平凡函数依赖于X，则Z传递依赖于X。记作$X \overset{传递}{\rightarrow} Z$

多值依赖：当属性组A的值确定时，属性组B的值与剩下的属性组无关，称为$A \rightarrow \rightarrow B$。
- 传递性
- 对称性
- 函数依赖是特殊情况

平凡的多值依赖：$U = A \cup B$

### 码
候选码：关系模式的属性组完全函数依赖于的属性（组）。

超码：关系模式的属性组部分函数依赖于的属性（组）。

主码：一个候选码。

主属性：任意候选码的元素。

### 范式
关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。

|范式名|要求|意义|
|:-:|-|-|
|1NF|分量不可分|*-*|
|2NF|非主属性完全函数依赖于任意一个候选码|解决插入、修改、删除异常|
|3NF|不存在码X、属性组Y、非主属性组Z使得Y函数依赖于X且Z非平凡函数依赖于Y|不存在传递依赖。解决插入、修改、删除异常|
|BCNF|每个非平凡函数依赖的决定因素都包含码|尽可能消除函数依赖|
|4NF|被非平凡多值依赖的属性组都有码|不存在非平凡非函数依赖的多值依赖|
|5NF|*-*|消除连接依赖|

### Armstrong公理系统
若满足一组函数依赖F的关系模式中存在函数依赖$X \rightarrow Y$，那么F逻辑蕴含$X \rightarrow Y$。

自反律：F逻辑蕴含每个平凡函数依赖。

增广律：F逻辑蕴含$X\rightarrow Y$，对属性组Z，有F逻辑蕴含$X\cup Z \rightarrow Y\cup Z$。

传递律：F逻辑蕴含的函数依赖的传递函数依赖被F逻辑蕴含。

由此关于函数依赖形成命题逻辑推理系统。

合并规则：$X \rightarrow Y \wedge Y \rightarrow Z \Rightarrow X \rightarrow Z$

伪传递规则：$X\rightarrow Y \wedge W\cup Y\rightarrow Z \Rightarrow X\cup W \rightarrow Z$

分解规则：$X\rightarrow Y \wedge Z \subseteq Y \Rightarrow X \rightarrow Z$

### 模式分解
无损连接性：关系模式的任一关系都等于该分解下所有子投影的自然连接。保证达到4NF

保持函数依赖：关系模式的函数依赖的闭包的该分解下所有子函数依赖的闭包的并。保证达到3NF

## 数据库设计
对特定的应用环境构造最优的数据库模式。

### 设计方法和步骤
人员：设计人员、操作员、程序员、用户

#### 需求分析
了解与分析用户需求，形成数据字典（描述数据项、数据结构、数据流、数据存储）。

#### 概念结构设计
通过数据抽象形成概念模型E-R图描述。

#### 逻辑结构设计
形成关系模型
|概念结构设计|逻辑结构设计|
|-|-|
|实体型|关系模式|
|码相同|合并|
|联系|独立关系模式/合并|

优化：极小化数据依赖、模式分解、规范化

设计用户子模式

#### 物理结构设计
存取方法：B+Tree索引、hash索引、聚簇方法

存储结构

评价物理结构

#### 数据库实施、运行、维护

数据载入、试运行、转储和恢复、安全性完整性控制、性能监督分析改造、重组织重构造

# 三、数据库实现原理
## 查询处理与优化
- 查询分析：扫描-词法分析-语法分析
- 查询检查：语义检查，形成查询树
- 查询优化：物理优化、代数优化；基于规则、基于代价（I/O+CPU+内存+通信）、基于语义
- 查询执行。

### 代数优化
#### 表达式等价变换
略

#### 查询树的启发式
- 选择先做
- 投影选择同时做
- 投影同相邻双目运算结合
- 选择与笛卡尔积结合形成连接
- 找公共子表达式

### 物理优化
#### 基于启发式规则
小关系：全表扫描
大关系：
- 主属性等于：索引扫描
- 非主属性=或属性上的其他查询：数目少索引扫描，否则全表扫描
- AND连接：组合索引、一般索引、全表扫描
- OR连接：全表扫描

连接操作：
- 排序合并
- 索引连接
- hash join
- 嵌套循环

#### 基于代价
计算代价

#### 基于语义
略

## 事务处理
### 事务的概念
事务是一组操作的集合，要么全部执行/提交，要么全部取消/回滚。
特点：
- Atomicity原子性：事务中的操作要么全部执行，要么全部取消
- Consistency一致性：一致性状态变化
- Isolation隔离性：事务之间互不干扰
- Durability持续性：事务完成则永久改变

故障：数据库本身破坏/数据出错
- 事务内部故障
- 系统故障
- 介质故障
- 计算机病毒

事务是并发控制的基本单位。

### 数据库恢复技术
#### 冗余数据建立
- 数据转储：利用后备副本。分为静态转储、动态转储；增量转储、海量转储
- 日志文件：记录事务引起的更新。先登记日志再更新数据。登记时按时间顺序。
  - 以记录为单位：开始标记-结束标记-更新，都是日志记录（事务标识-操作类型-操作对象-旧值-新值）。
  - 以数据块为单位：事务标识-数据块

#### 回复策略
- 事务故障：反向扫描、执行逆操作，直至事务开始标记
- 系统故障：正向扫描，建立已提交（重做）-尚未完成（撤销）两个事务队列。撤销未完成事务。重做已完成事务。
- 介质故障：装入最新的后备副本和日志文件，重做已完成事务。

#### 检查点记录
内容：
- 正在执行事务
- 事务的最近日志记录。

周期性的建立检查点：
- 写入日志
- 写入检查点
- 数据记录写入数据库
- 写入重新开始文件

恢复时（最近检查点）：正向处理
- 检查点之前提交：无视
- 检查点之后提交、之前开始：重做
- 检查点之后提交：撤销

#### 数据库镜像
全部复制

### 数据库并发控制
保证事务的ACID。

#### 并发问题
- 修改丢失
- 不可重复读
- 读脏数据

#### （封）锁
基本锁
- 排他锁/写锁/X锁：事务T读取和修改，不能加锁
- 共享锁/读锁/S锁：事务T只读，能加S锁

封锁协议：
- 一级：修改加X锁，直至事务结束。防止修改丢失、事务可恢复。
- 二级：一级+读加S锁，直至读完。防止读脏数据。
- 三级：一级+读加S锁，直至事务结束。防止不可重复读、读脏数据。

活锁：事务可能因为锁而永远等待。采用先来先服务解决

死锁：事务间因为锁而互相等待。
解决：
- 预防：
  - 一次封锁法：全部申请
  - 顺序封锁法：按顺序申请
- 诊断与解决：
  - 超时法：事务等待时间长
  - 等待图法：画等待图，环=死锁
- 撤销：代价最小的事务撤销

#### 并发调度的正确性
可串行化：与某种串行执行结果相同。

可串行性：可串行化的并发执行。

冲突操作：不同事务同时对同一个数据读写/写写。

冲突可串行化：交换不冲突操作的顺序可串行化。冲突可串行化必然可串行化。

#### 两段锁协议
先全部申请，再全部释放。

任何对遵循两段锁协议的事务的并发调度都是可串行化的。

#### 锁粒度
不同级别的数据库对象形成多粒度树。对一个节点加锁（显式加锁）则所有子节点加锁（隐式加锁）。

意向锁：下层节点将会加锁。加锁必须为所有上层节点加相应意向锁。
- 意向共享锁/IS锁：子节点将加S锁。
- 意向排他锁/IX锁：子节点将加X锁。
- 共享意向排他锁/SIX锁：加S锁，加IX锁。
